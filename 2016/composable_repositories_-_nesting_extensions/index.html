<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  

  <title>Composable Repositories - Nesting Extensions</title>
  <meta name="description" content="A look at several problems with nesting extension methods in LINQ and how to get around these issues with and expression visitor.">
  <meta name="author" content="Luke McGregor">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Composable Repositories - Nesting Extensions">
  <meta name="twitter:description" content="A look at several problems with nesting extension methods in LINQ and how to get around these issues with and expression visitor.">
  
  <meta name="twitter:creator" content="staticv0id">
  
  <meta name="twitter:image" content="/images/favicons/favicon-194x194.png" />

  <meta property="og:type" content="article">
  <meta property="og:title" content="Composable Repositories - Nesting Extensions">
  <meta property="og:description" content="A look at several problems with nesting extension methods in LINQ and how to get around these issues with and expression visitor.">
  <meta property="og:image" content="/images/favicons/favicon-194x194.png" />

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css?1529805841291185400">
  <link rel="canonical" href="http://blog.staticvoid.co.nz/2016/composable_repositories_-_nesting_extensions/">
  <link rel="alternate" type="application/rss+xml" title="StaticVoid" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
	<div class="panel-main">

		<div class="panel-main__inner panel-inverted">
			<div class="panel-main__content">
				<a href="/" title="link to home of StaticVoid">
					<img src="https://www.gravatar.com/avatar/46e93e55b8f4f652201516c2f7bf3323?s=256" class="user-image" alt="Profile Photo">
					<div class="staticvoid-logo">
						<div class="wrapper">
							<div class="code">static void;</div>
							<div class="comment">// Blog</div>
						</div>
					</div>
				</a>
				<hr class="panel-cover__divider">

				<div class="navigation-wrapper">

					<nav class="cover-navigation cover-navigation--primary">
						<ul class="navigation">							
							<li class="navigation__item"><a href="/" title="Tech">Tech</a></li>
							<li class="navigation__item"><a href="/personal" title="Personal">Personal</a></li>
						</ul>
					</nav>

					<nav class="cover-navigation navigation--social">
						<ul class="navigation">

							
							<!-- Twitter -->
							<li class="navigation__item">
								<a href="http://twitter.com/staticv0id" title="@staticv0id on Twitter" target="_blank">
									<i class="icon icon-social-twitter"></i>
									<span class="label">Twitter</span>
								</a>
							</li>
							   
							<!-- GitHub -->
							<li class="navigation__item">
								<a href="https://www.github.com/lukemcgregor" title="lukemcgregor on GitHub" target="_blank">
									<i class="icon icon-social-github"></i>
									<span class="label">GitHub</span>
								</a>
							</li>
							 

							<!-- RSS -->
							<li class="navigation__item">
								<a href="/feed.xml" title="Subscribe" target="_blank">
									<i class="icon icon-rss"></i>
									<span class="label">RSS</span>
								</a>
							</li>

						</ul>
					</nav>

				</div>

			</div>

		</div>

		<div class="panel-cover--overlay"></div>
	</div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="24 Oct 2016" class="post-meta__date date">24 Oct 2016</time>
      
    </div>
    <h1 class="post-title">Composable Repositories - Nesting Extensions</h1>
  </header>

  <section class="post">
    <p>In my previous post <a href="http://blog.staticvoid.co.nz/2015/9/8/composable_repositories">Composable Repositories</a>, I introduced using extension methods as the repository in applications. This allows repositories to get much better reuse and be more expressive in their usage. In this post I will look at two issues with extension method based repositories in LINQ and introduce some libraries I built to resolve these issues.</p>

<p>First a refresher, in my previous post I used the following query as an example.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;</span> <span class="nf">InRegion</span><span class="p">(</span><span class="k">this</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;</span> <span class="n">people</span><span class="p">,</span> <span class="kt">string</span> <span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Addresses</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Region</span> <span class="p">==</span> <span class="n">region</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">IOrderedQueryable</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;</span> <span class="nf">OrderByName</span><span class="p">(</span><span class="k">this</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;</span> <span class="n">people</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="nf">OrderBy</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Page</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IOrderedQueryable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">entities</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pageSize</span> <span class="p">=</span> <span class="m">3</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">skip</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">page</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">pageSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">entities</span><span class="p">.</span><span class="nf">Skip</span><span class="p">(</span><span class="n">skip</span><span class="p">).</span><span class="nf">Take</span><span class="p">(</span><span class="n">pageSize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">PersonModel</span><span class="p">&gt;</span> <span class="nf">ToViewModels</span><span class="p">(</span><span class="k">this</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;</span> <span class="n">people</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">person</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">PersonModel</span>
    <span class="p">{</span>
        <span class="n">Name</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
        <span class="n">Addresses</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">Addresses</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">PostalAddress</span><span class="p">)</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="c1">//and the query</span>
<span class="n">Context</span><span class="p">.</span><span class="n">People</span>
    <span class="p">.</span><span class="nf">InRegion</span><span class="p">(</span><span class="s">"Shire"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">OrderByName</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">Page</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ToViewModels</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>
</code></pre></div></div>

<p>As you can see this uses chained extension methods to generate the underlying query.</p>

<h3 id="issue-one-queryable-extensions-in-the-projection">Issue one: Queryable extensions in the projection</h3>

<p>This brings us to the first issue, if you look at the <code class="highlighter-rouge">ToViewModels</code> projection call you will see the following:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Addresses</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">Addresses</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">PostalAddress</span><span class="p">)</span>
</code></pre></div></div>

<p>Now wouldn’t it be better if we could nest our extension methods here and reuse another projection which relates to addresses? Something like the following:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Addresses</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">Addresses</span><span class="p">.</span><span class="nf">ToAddressViewModels</span><span class="p">()</span>
</code></pre></div></div>

<p>Now if you write this and execute it with Entity Framework you will get the following error:</p>

<blockquote>
  <p>LINQ to Entities does not recognize the method ‘ToAddressViewModels(Address)’ method, and this method cannot be translated into a store expression.</p>
</blockquote>

<p>This is a bit weird as we seem to be able to use extension methods elsewhere in our queries without issue, why is this instance different? Why can we use <code class="highlighter-rouge">Select</code> but not our extension which just does a select internally, The problem here comes down to where this occurs in our expression. As you can see in our extension this is not acting on the root queryable directly but instead effecting what essentially amounts to a sub query.</p>

<p>When we were acting directly on the queryable the LINQ method was essentially visiting the expression <em>returned</em> by our extension methods, however when we use an extension inside the results nothing has been returned yet so the expression visitor needs to evaluate and translate that method to an expression. The issue is that the visitor at that point doesn’t know that the extension you wrote is just another expression (or even that it could possibly be an expression).</p>

<h3 id="issue-two-single-element-projection">Issue two: Single element projection</h3>

<p>Imagine our projection was instead into a singular, for example</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Address</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">Address</span><span class="p">.</span><span class="nf">ToViewModel</span><span class="p">()</span>
</code></pre></div></div>

<p>This is a very similar problem to that which we are looking at above with one key distinction, we are no longer acting with set based (queryable) logic, instead we are acting on a singular element. At its heart is the same problem as above but it is a little harder to get around.</p>

<p>It would be desirable to solve both of these problems to allow even more expressive queries, especially in relation to projection of entities.</p>

<h2 id="the-solution">The solution</h2>

<p>To be able to solve these problems we need to get into the depths of LINQ and translate our extension methods for the benefit of the downstream expression visitors. This is possible by writing a new expression visitor which replaces the extension method calls in the expression tree with the actual expressions we wanted to execute. This will let our Entity Framework (or generic LINQ based ORM) expression visitor carry on with its translation to SQL without needing to understand the internals of our extension method.</p>

<h4 id="plugging-into-the-pipeline">Plugging into the pipeline</h4>

<p>The first thing we will need to do is to get our own expression visitor into the mix, we can do this can build a our own <a href="https://github.com/lukemcgregor/LinqExpander/blob/master/LinqExpander/ExpandableQuery.cs">queryable implementation</a>, and a <a href="https://github.com/lukemcgregor/LinqExpander/blob/master/LinqExpander/AsExpandableExtension.cs">queryable extension</a> to convert to our new queryable implementation. This will let us get amongst with our own <a href="https://github.com/lukemcgregor/LinqExpander/blob/master/LinqExpander/ExpandableVisitor.cs">expression visitor</a> which is executed as we walk the expression tree.</p>

<p>This means we can do something like this to let our expression visitor participate in translating the LINQ query.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Context</span><span class="p">.</span><span class="n">People</span>
    <span class="p">.</span><span class="nf">AsExpandable</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">InRegion</span><span class="p">(</span><span class="s">"Shire"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">OrderByName</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">Page</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ToViewModels</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>
</code></pre></div></div>

<p>We are interested especially in the <code class="highlighter-rouge">VisitMethodCall</code> part of the visitor which will get executed for every extension method. At this point we could intercept and do something with every extension method that gets executed in LINQ but this would mean we would need to manually exclude things which Entity Framework understands (like <code class="highlighter-rouge">Select</code> and <code class="highlighter-rouge">Where</code>) and also potentially run into the same problem with things which aren’t actually translatable to SQL, so instead we are going to use a marker attribute to tag extension methods we are OK with replacing, <code class="highlighter-rouge">ExpandQueryableAttribute</code>. Inside the visitor we will then replace any of these queryable replacements with the invoked/expressionised version of the queryable.</p>

<p>This can be used as follows:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[ExpandQueryable]</span>
<span class="k">public</span> <span class="k">static</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">AddressModel</span><span class="p">&gt;</span> <span class="nf">ToViewModels</span><span class="p">(</span><span class="k">this</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">Address</span><span class="p">&gt;</span> <span class="n">addresses</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">addresses</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">address</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">AddressModel</span>
    <span class="p">{</span>
        <span class="n">StreetNumber</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">Number</span><span class="p">,</span>
        <span class="n">Street</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">Line1</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Voila problem one solved.</p>

<p>The next part will be a little more ninja, to replace the non-queryable parts we don’t have anything to invoke and return us an expression. So we are going to need to change the way we write our extension methods to be a little more expression-like. Lets write our singular projection as an expression:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">Addresss</span><span class="p">,</span> <span class="n">AddressModel</span><span class="p">&gt;&gt;</span> <span class="nf">ToViewModelExpression</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">address</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">AddressModel</span>
    <span class="p">{</span>
        <span class="n">StreetNumber</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">Number</span><span class="p">,</span>
        <span class="n">Street</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">Line1</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This isn’t really usable in our expression tree yet as we don’t have an entry point from our query. Getting an entry point is a little tricky as how do we can’t just use an expression on a singular without invoking it (which would get us right back to the original problem. So we are going to use a little bit of a trick, let’s create an extension method and use it as a placeholder for the actual expression. We will decorate this with an attribute which points back to the actual expression to execute in its place. When we visit such an extension method in our visitor we will replace it with the expression from the attribute in the expression tree.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[ReplaceInExpressionTree(MethodName = nameof(ToViewModelExpression))]</span>
<span class="k">public</span> <span class="k">static</span> <span class="n">AddressModel</span> <span class="nf">ToViewModel</span><span class="p">(</span><span class="k">this</span> <span class="n">Address</span> <span class="n">entity</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// We could throw a not implemented exception here as we won't ever</span>
    <span class="c1">// execute this unless we use it outside of our visitor. But doing this</span>
    <span class="c1">// allows you to use the extension on an in memory object tree without</span>
    <span class="c1">// needing our custom visitor to replace it.</span>
    <span class="k">return</span> <span class="nf">ToViewModelExpression</span><span class="p">().</span><span class="nf">Compile</span><span class="p">()(</span><span class="n">entity</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This means we can now use our singular extension methods inside our projections, and both of our original problems are solved.</p>

<p>To save you having to write all of this complex expression magic in you application I have put this library on Nuget and <a href="https://github.com/lukemcgregor/LinqExpander">Github</a></p>

<pre class="nuget-button" style="width:100px">Install-Package StaticVoid.Core.IO</pre>

<p>A big thanks to those who helped me learn how expression trees work on StackOverflow in the following questions:</p>

<ul>
  <li><a href="http://stackoverflow.com/q/39864270/1070291">Expression visitor only calling VisitParameter for some lambda expressions</a></li>
  <li><a href="http://stackoverflow.com/q/39585427/1070291">Projection of single entities in EF with extension methods</a></li>
</ul>

<p>And to <a href="http://stackoverflow.com/a/10726256/1070291">@LordTerabyte</a>  whose <a href="http://pastebin.com/4fMjaCMV">code</a> I used as a starting point for these extensions.</p>

<h2 id="magic-but-whats-the-point">Magic but whats the point?</h2>

<p>By enabling nesting in our extension methods we can nest our projections so that we can take our data model and transform it into a more appropriate usage model for use in our applications. We can then reuse these translation extensions so if we want something in the a usage model we always use the same code.</p>

<p>But probably more importantly this allows us to solve an under/over fetch problem. All of the projection code is essentially executed inside of SQL, this means that the full data model is available so we don’t need to worry about including the joined tables we require to ensure those navigation properties are not null. We also don’t need to worry about including too much information in the result set as we are only going to get the columns which directly map to our projected model. This is a really big benefit in terms of both code complexity and potential performance bottlenecks.</p>

<h4 id="a-final-word-of-caution">A final word of caution</h4>

<p>This method allows you to push far more logic into SQL for processing. Be very careful to keep in mind the queries you are generating with nested projection and be sure that the SQL you are generating is kept performant. If you aren’t careful about what you write (as with any LINQ based query) you can execute things which are a little crazy when transpiled to SQL.</p>

  </section>
  <section id="disqus_thread"></section><!-- /#disqus_thread -->
</article>

    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://blog.staticvoid.co.nz/2016/composable_repositories_-_nesting_extensions/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/composable_repositories_-_nesting_extensions'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };

      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//staticvoidblog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
       })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



<script type="application/ld+json">
{ "@context": "http://schema.org",
 "@type": "BlogPosting",
 "headline": "Composable Repositories - Nesting Extensions",
 "wordcount": "1845",
 "publisher": "StaticVoid",
 "mainEntityOfPage": "http://blog.staticvoid.co.nz/2016/composable_repositories_-_nesting_extensions/",
 "publisher": {
   "@type": "Organization",
   "name": "StaticVoid",
  "logo":{
    "@type":"ImageObject",
    "url": "http://blog.staticvoid.co.nz/images/favicons/favicon-194x194.png"
  }
 },
 "datePublished": "2016-10-24 00:00:00 +0000",
 "description": "A look at several problems with nesting extension methods in LINQ and how to get around these issues with and expression visitor.",
   "author": {
    "@type": "Person",
    "name": "Luke McGregor"
	,"image": "https://www.gravatar.com/avatar/46e93e55b8f4f652201516c2f7bf3323?s=256"
  }
 }
</script>

      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2018 Luke McGregor. All rights reserved.</span>
</footer>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1529805841291185400"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-28637942-1', 'auto');
  ga('send', 'pageview');
</script>


    </div>
  </body>
</html>